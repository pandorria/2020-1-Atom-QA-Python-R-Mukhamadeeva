{"name": "test_reg_incorrect_username_length_min", "status": "broken", "statusDetails": {"message": "sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2013, 'Lost connection to MySQL server during query')\n(Background on this error at: http://sqlalche.me/e/e3q8)", "trace": "self = Engine(mysql+pymysql://root:***@127.0.0.1:3306/)\nfn = <bound method Pool.unique_connection of <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>>\nconnection = None\n\n    def _wrap_pool_connect(self, fn, connection):\n        dialect = self.dialect\n        try:\n>           return fn()\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2262: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>\n\n    def unique_connection(self):\n        \"\"\"Produce a DBAPI connection that is not referenced by any\n        thread-local context.\n    \n        This method is equivalent to :meth:`.Pool.connect` when the\n        :paramref:`.Pool.use_threadlocal` flag is not set to True.\n        When :paramref:`.Pool.use_threadlocal` is True, the\n        :meth:`.Pool.unique_connection` method provides a means of bypassing\n        the threadlocal context.\n    \n        \"\"\"\n>       return _ConnectionFairy._checkout(self)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:294: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'sqlalchemy.pool.base._ConnectionFairy'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>\nthreadconns = None, fairy = None\n\n    @classmethod\n    def _checkout(cls, pool, threadconns=None, fairy=None):\n        if not fairy:\n>           fairy = _ConnectionRecord.checkout(pool)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:751: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'sqlalchemy.pool.base._ConnectionRecord'>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>\n\n    @classmethod\n    def checkout(cls, pool):\n>       rec = pool._do_get()\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:483: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %d\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n                return self._create_connection()\n            except:\n                with util.safe_reraise():\n>                   self._dec_overflow()\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/impl.py:138: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.util.langhelpers.safe_reraise object at 0x10c702f90>\ntype_ = None, value = None, traceback = None\n\n    def __exit__(self, type_, value, traceback):\n        # see #2703 for notes\n        if type_ is None:\n            exc_type, exc_value, exc_tb = self._exc_info\n            self._exc_info = None  # remove potential circular references\n            if not self.warn_only:\n>               compat.reraise(exc_type, exc_value, exc_tb)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:68: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ntp = <class 'pymysql.err.OperationalError'>\nvalue = OperationalError(2013, 'Lost connection to MySQL server during query')\ntb = <traceback object at 0x10c70b690>, cause = None\n\n    def reraise(tp, value, tb=None, cause=None):\n        if cause is not None:\n            assert cause is not value, \"Same cause emitted\"\n            value.__cause__ = cause\n        if value.__traceback__ is not tb:\n            raise value.with_traceback(tb)\n>       raise value\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/util/compat.py:129: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>\n\n    def _do_get(self):\n        use_overflow = self._max_overflow > -1\n    \n        try:\n            wait = use_overflow and self._overflow >= self._max_overflow\n            return self._pool.get(wait, self._timeout)\n        except sqla_queue.Empty:\n            # don't do things inside of \"except Empty\", because when we say\n            # we timed out or can't connect and raise, Python 3 tells\n            # people the real error is queue.Empty which it isn't.\n            pass\n        if use_overflow and self._overflow >= self._max_overflow:\n            if not wait:\n                return self._do_get()\n            else:\n                raise exc.TimeoutError(\n                    \"QueuePool limit of size %d overflow %d reached, \"\n                    \"connection timed out, timeout %d\"\n                    % (self.size(), self.overflow(), self._timeout),\n                    code=\"3o7r\",\n                )\n    \n        if self._inc_overflow():\n            try:\n>               return self._create_connection()\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/impl.py:135: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>\n\n    def _create_connection(self):\n        \"\"\"Called by subclasses to create a new ConnectionRecord.\"\"\"\n    \n>       return _ConnectionRecord(self)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:299: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x10c700110>\npool = <sqlalchemy.pool.impl.QueuePool object at 0x10a510b90>, connect = True\n\n    def __init__(self, pool, connect=True):\n        self.__pool = pool\n        if connect:\n>           self.__connect(first_connect_check=True)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:428: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.pool.base._ConnectionRecord object at 0x10c700110>\nfirst_connect_check = True\n\n    def __connect(self, first_connect_check=False):\n        pool = self.__pool\n    \n        # ensure any existing connection is removed, so that if\n        # creator fails, this attribute stays None\n        self.connection = None\n        try:\n            self.starttime = time.time()\n>           connection = pool._invoke_creator(self)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nconnection_record = <sqlalchemy.pool.base._ConnectionRecord object at 0x10c700110>\n\n    def connect(connection_record=None):\n        if dialect._has_events:\n            for fn in dialect.dispatch.do_connect:\n                connection = fn(\n                    dialect, connection_record, cargs, cparams\n                )\n                if connection is not None:\n                    return connection\n>       return dialect.connect(*cargs, **cparams)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:114: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x10bde3710>\ncargs = ()\ncparams = {'client_flag': 2, 'host': '127.0.0.1', 'passwd': 'renata', 'port': 3306, ...}\n\n    def connect(self, *cargs, **cparams):\n>       return self.dbapi.connect(*cargs, **cparams)\n\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/default.py:453: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = ()\nkwargs = {'client_flag': 2, 'host': '127.0.0.1', 'passwd': 'renata', 'port': 3306, ...}\nConnection = <class 'pymysql.connections.Connection'>\n\n    def Connect(*args, **kwargs):\n        \"\"\"\n        Connect to the database; see connections.Connection.__init__() for\n        more information.\n        \"\"\"\n        from .connections import Connection\n>       return Connection(*args, **kwargs)\n\n/usr/local/lib/python3.7/site-packages/pymysql/__init__.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x10c7000d0>\nhost = '127.0.0.1', user = 'root', password = 'renata', database = None\nport = 3306, unix_socket = None, charset = '', sql_mode = None\nread_default_file = None\nconv = {<class 'bool'>: <function escape_bool at 0x10c640320>, <class 'int'>: <function escape_int at 0x10c640440>, <class 'float'>: <function escape_float at 0x10c6404d0>, <class 'str'>: <function escape_unicode at 0x10c640710>, ...}\nuse_unicode = True, client_flag = 3842567\ncursorclass = <class 'pymysql.cursors.Cursor'>, init_command = None\nconnect_timeout = 10, ssl = None, read_default_group = None, compress = None\nnamed_pipe = None, autocommit = False, db = None, passwd = 'renata'\nlocal_infile = False, max_allowed_packet = 16777216, defer_connect = False\nauth_plugin_map = None, read_timeout = None, write_timeout = None\nbind_address = None, binary_prefix = False, program_name = None\nserver_public_key = None\n\n    def __init__(self, host=None, user=None, password=\"\",\n                 database=None, port=0, unix_socket=None,\n                 charset='', sql_mode=None,\n                 read_default_file=None, conv=None, use_unicode=None,\n                 client_flag=0, cursorclass=Cursor, init_command=None,\n                 connect_timeout=10, ssl=None, read_default_group=None,\n                 compress=None, named_pipe=None,\n                 autocommit=False, db=None, passwd=None, local_infile=False,\n                 max_allowed_packet=16*1024*1024, defer_connect=False,\n                 auth_plugin_map=None, read_timeout=None, write_timeout=None,\n                 bind_address=None, binary_prefix=False, program_name=None,\n                 server_public_key=None):\n        if use_unicode is None and sys.version_info[0] > 2:\n            use_unicode = True\n    \n        if db is not None and database is None:\n            database = db\n        if passwd is not None and not password:\n            password = passwd\n    \n        if compress or named_pipe:\n            raise NotImplementedError(\"compress and named_pipe arguments are not supported\")\n    \n        self._local_infile = bool(local_infile)\n        if self._local_infile:\n            client_flag |= CLIENT.LOCAL_FILES\n    \n        if read_default_group and not read_default_file:\n            if sys.platform.startswith(\"win\"):\n                read_default_file = \"c:\\\\my.ini\"\n            else:\n                read_default_file = \"/etc/my.cnf\"\n    \n        if read_default_file:\n            if not read_default_group:\n                read_default_group = \"client\"\n    \n            cfg = Parser()\n            cfg.read(os.path.expanduser(read_default_file))\n    \n            def _config(key, arg):\n                if arg:\n                    return arg\n                try:\n                    return cfg.get(read_default_group, key)\n                except Exception:\n                    return arg\n    \n            user = _config(\"user\", user)\n            password = _config(\"password\", password)\n            host = _config(\"host\", host)\n            database = _config(\"database\", database)\n            unix_socket = _config(\"socket\", unix_socket)\n            port = int(_config(\"port\", port))\n            bind_address = _config(\"bind-address\", bind_address)\n            charset = _config(\"default-character-set\", charset)\n            if not ssl:\n                ssl = {}\n            if isinstance(ssl, dict):\n                for key in [\"ca\", \"capath\", \"cert\", \"key\", \"cipher\"]:\n                    value = _config(\"ssl-\" + key, ssl.get(key))\n                    if value:\n                        ssl[key] = value\n    \n        self.ssl = False\n        if ssl:\n            if not SSL_ENABLED:\n                raise NotImplementedError(\"ssl module not found\")\n            self.ssl = True\n            client_flag |= CLIENT.SSL\n            self.ctx = self._create_ssl_ctx(ssl)\n    \n        self.host = host or \"localhost\"\n        self.port = port or 3306\n        self.user = user or DEFAULT_USER\n        self.password = password or b\"\"\n        if isinstance(self.password, text_type):\n            self.password = self.password.encode('latin1')\n        self.db = database\n        self.unix_socket = unix_socket\n        self.bind_address = bind_address\n        if not (0 < connect_timeout <= 31536000):\n            raise ValueError(\"connect_timeout should be >0 and <=31536000\")\n        self.connect_timeout = connect_timeout or None\n        if read_timeout is not None and read_timeout <= 0:\n            raise ValueError(\"read_timeout should be >= 0\")\n        self._read_timeout = read_timeout\n        if write_timeout is not None and write_timeout <= 0:\n            raise ValueError(\"write_timeout should be >= 0\")\n        self._write_timeout = write_timeout\n        if charset:\n            self.charset = charset\n            self.use_unicode = True\n        else:\n            self.charset = DEFAULT_CHARSET\n            self.use_unicode = False\n    \n        if use_unicode is not None:\n            self.use_unicode = use_unicode\n    \n        self.encoding = charset_by_name(self.charset).encoding\n    \n        client_flag |= CLIENT.CAPABILITIES\n        if self.db:\n            client_flag |= CLIENT.CONNECT_WITH_DB\n    \n        self.client_flag = client_flag\n    \n        self.cursorclass = cursorclass\n    \n        self._result = None\n        self._affected_rows = 0\n        self.host_info = \"Not connected\"\n    \n        # specified autocommit mode. None means use server default.\n        self.autocommit_mode = autocommit\n    \n        if conv is None:\n            conv = converters.conversions\n    \n        # Need for MySQLdb compatibility.\n        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}\n        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}\n        self.sql_mode = sql_mode\n        self.init_command = init_command\n        self.max_allowed_packet = max_allowed_packet\n        self._auth_plugin_map = auth_plugin_map or {}\n        self._binary_prefix = binary_prefix\n        self.server_public_key = server_public_key\n    \n        self._connect_attrs = {\n            '_client_name': 'pymysql',\n            '_pid': str(os.getpid()),\n            '_client_version': VERSION_STRING,\n        }\n    \n        if program_name:\n            self._connect_attrs[\"program_name\"] = program_name\n    \n        if defer_connect:\n            self._sock = None\n        else:\n>           self.connect()\n\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:325: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x10c7000d0>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6>\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG: print('connected using socket')\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                sock.settimeout(None)\n                sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n            self._sock = sock\n            self._rfile = _makefile(sock, 'rb')\n            self._next_seq_id = 0\n    \n>           self._get_server_information()\n\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:598: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x10c7000d0>\n\n    def _get_server_information(self):\n        i = 0\n>       packet = self._read_packet()\n\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:975: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x10c7000d0>\npacket_type = <class 'pymysql.protocol.MysqlPacket'>\n\n    def _read_packet(self, packet_type=MysqlPacket):\n        \"\"\"Read an entire \"mysql packet\" in its entirety from the network\n        and return a MysqlPacket type that represents the results.\n    \n        :raise OperationalError: If the connection to the MySQL server is lost.\n        :raise InternalError: If the packet sequence number is wrong.\n        \"\"\"\n        buff = b''\n        while True:\n>           packet_header = self._read_bytes(4)\n\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:657: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x10c7000d0>, num_bytes = 4\n\n    def _read_bytes(self, num_bytes):\n        self._sock.settimeout(self._read_timeout)\n        while True:\n            try:\n                data = self._rfile.read(num_bytes)\n                break\n            except (IOError, OSError) as e:\n                if e.errno == errno.EINTR:\n                    continue\n                self._force_close()\n                raise err.OperationalError(\n                    CR.CR_SERVER_LOST,\n                    \"Lost connection to MySQL server during query (%s)\" % (e,))\n            except BaseException:\n                # Don't convert unknown exception to MySQLError.\n                self._force_close()\n                raise\n        if len(data) < num_bytes:\n            self._force_close()\n            raise err.OperationalError(\n>               CR.CR_SERVER_LOST, \"Lost connection to MySQL server during query\")\nE           pymysql.err.OperationalError: (2013, 'Lost connection to MySQL server during query')\n\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:707: OperationalError\n\nThe above exception was the direct cause of the following exception:\n\nrequest = <SubRequest 'start_session' for <Function test_add_user_incorrect_username_length>>\n\n    @pytest.fixture(scope=\"session\", autouse=True)\n    def start_session(request):\n        global app_name\n        containers = []\n        mock_port = 5000\n        mysql_name = 'mysql_db'\n        mysql_port = 3306\n        app_port = 3000\n        client = docker.from_env()\n        try:\n            mysql_container = client.containers.run('mysql:latest', detach=True, ports={f'{mysql_port}/tcp': mysql_port},\n                                                    name=mysql_name,\n                                                    environment={'MYSQL_ROOT_PASSWORD': 'renata'},\n                                                    )\n        except:\n            time.sleep(60)\n            return None\n        containers.append(mysql_container)\n        time.sleep(40)\n>       MysqlOrmBuilder(MysqlOrmConnection('root', 'renata', 'users'))\n\nconftest.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \norm/orm_client.py:14: in __init__\n    self.connection = self.connect()\norm/orm_client.py:37: in connect\n    connection = self.get_connection()\norm/orm_client.py:34: in get_connection\n    return engine.connect()\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2193: in connect\n    return self._connection_cls(self, **kwargs)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:103: in __init__\n    else engine.raw_connection()\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2293: in raw_connection\n    self.pool.unique_connection, _connection\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2266: in _wrap_pool_connect\n    e, dialect, self\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:1536: in _handle_dbapi_exception_noconnection\n    util.raise_from_cause(sqlalchemy_exception, exc_info)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/util/compat.py:383: in raise_from_cause\n    reraise(type(exception), exception, tb=exc_tb, cause=cause)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/util/compat.py:128: in reraise\n    raise value.with_traceback(tb)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/base.py:2262: in _wrap_pool_connect\n    return fn()\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:294: in unique_connection\n    return _ConnectionFairy._checkout(self)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:751: in _checkout\n    fairy = _ConnectionRecord.checkout(pool)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:483: in checkout\n    rec = pool._do_get()\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/impl.py:138: in _do_get\n    self._dec_overflow()\n/usr/local/lib/python3.7/site-packages/sqlalchemy/util/langhelpers.py:68: in __exit__\n    compat.reraise(exc_type, exc_value, exc_tb)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/util/compat.py:129: in reraise\n    raise value\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/impl.py:135: in _do_get\n    return self._create_connection()\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:299: in _create_connection\n    return _ConnectionRecord(self)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:428: in __init__\n    self.__connect(first_connect_check=True)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/pool/base.py:630: in __connect\n    connection = pool._invoke_creator(self)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/strategies.py:114: in connect\n    return dialect.connect(*cargs, **cparams)\n/usr/local/lib/python3.7/site-packages/sqlalchemy/engine/default.py:453: in connect\n    return self.dbapi.connect(*cargs, **cparams)\n/usr/local/lib/python3.7/site-packages/pymysql/__init__.py:94: in Connect\n    return Connection(*args, **kwargs)\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:325: in __init__\n    self.connect()\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:598: in connect\n    self._get_server_information()\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:975: in _get_server_information\n    packet = self._read_packet()\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:657: in _read_packet\n    packet_header = self._read_bytes(4)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pymysql.connections.Connection object at 0x10c7000d0>, num_bytes = 4\n\n    def _read_bytes(self, num_bytes):\n        self._sock.settimeout(self._read_timeout)\n        while True:\n            try:\n                data = self._rfile.read(num_bytes)\n                break\n            except (IOError, OSError) as e:\n                if e.errno == errno.EINTR:\n                    continue\n                self._force_close()\n                raise err.OperationalError(\n                    CR.CR_SERVER_LOST,\n                    \"Lost connection to MySQL server during query (%s)\" % (e,))\n            except BaseException:\n                # Don't convert unknown exception to MySQLError.\n                self._force_close()\n                raise\n        if len(data) < num_bytes:\n            self._force_close()\n            raise err.OperationalError(\n>               CR.CR_SERVER_LOST, \"Lost connection to MySQL server during query\")\nE           sqlalchemy.exc.OperationalError: (pymysql.err.OperationalError) (2013, 'Lost connection to MySQL server during query')\nE           (Background on this error at: http://sqlalche.me/e/e3q8)\n\n/usr/local/lib/python3.7/site-packages/pymysql/connections.py:707: OperationalError"}, "description": "\n        Тестируется негативный сценарий, когда производится попытка зарегестрировать пользователя с длиной поля\n        usеrname, не проходящей минимальную допустимую границу\n        Приложение работает корректно и пользователю выводится сообщение об ошибке\n        ", "start": 1590608899961, "stop": 1590608899961, "uuid": "ab183c1b-f83b-497f-a330-153626945832", "historyId": "834ffd30c2c87d6f0d139f7176edcc9b", "testCaseId": "d8aa561fea2f2fe9512b5be739fe0790", "fullName": "tests.test_ui.TestReg#test_reg_incorrect_username_length_min", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "test_ui"}, {"name": "subSuite", "value": "TestReg"}, {"name": "host", "value": "MacBook-Air-Roman-2.local"}, {"name": "thread", "value": "20658-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "tests.test_ui"}]}